# Sublime
alias subl='sublime'

# Kube Solo Shell
# kube-solo-shell() {
#
#   # add ssh key to Keychain
#   ssh-add -K ~/.ssh/id_rsa &>/dev/null
#
#   # get App's Resources folder
#   res_folder=$(cat ~/kube-solo/.env/resouces_path)
#
#   # get VM IP
#   vm_ip=$("${res_folder}"/bin/corectl q -i k8solo-01)
#
#   # path to the bin folder where we store our binary files
#   export PATH=${HOME}/kube-solo/bin:$PATH
#
#   # set etcd endpoint
#   export ETCDCTL_PEERS=http://$vm_ip:2379
#   echo " "
#   echo "etcdctl ls /:"
#   etcdctl --no-sync ls /
#   echo " "
#
#   # set fleetctl endpoint
#   export FLEETCTL_TUNNEL=
#   export FLEETCTL_ENDPOINT=http://$vm_ip:2379
#   export FLEETCTL_DRIVER=etcd
#   export FLEETCTL_STRICT_HOST_KEY_CHECKING=false
#   echo "fleetctl list-machines:"
#   fleetctl list-machines
#   echo " "
#   echo "fleetctl list-units:"
#   fleetctl list-units
#   echo " "
#
#   # set kubernetes master
#   export KUBERNETES_MASTER=http://$vm_ip:8080
#   echo "kubectl get nodes:"
#   kubectl get nodes
#   echo " "
#
#   cd ~/kube-solo
#
# }

# Minikube start
# minikube-start() {
#   echo "*** Starting minikube cluster..."
#   cd $HOME/Projects/minikube
#   ./minikube start
#
#   MINIKUBE_IP=$(VBoxManage guestproperty get "minikubeVM" "/VirtualBox/GuestInfo/Net/1/V4/IP" | awk '{ print($2); }')
#   MINIKUBE_SERVER=http://$MINIKUBE_IP:8080
#
#   echo "*** Configuring kubectl to use minikube at $MINIKUBE_SERVER..."
#   kubectl config set-cluster minikube --insecure-skip-tls-verify=true --server=$MINIKUBE_SERVER
#   kubectl config set-context minikube --cluster=minikube
#   kubectl config use-context minikube
# }

# Docker Machine init (obsolete with Docker for Mac)
# init-docker() {
#
#   echo "dm-env: Use Docker for Mac instead"
#   return 0
#
#   if [ -z "$1" ]; then
#     local machine=dev
#   else
#     local machine=$1
#   fi
#
#   dm-env $machine
#
#   echo "*** Updating .autoenv.zsh..."
#   [ -e ".autoenv.zsh" ] \
#     && gsed -i '/\(.*\) # Generated by init-docker/d' .autoenv.zsh
#   echo "dm-env ${machine} # Generated by init-docker" >> .autoenv.zsh
#
# }

# Docker Machine autoenv init
# dm-env() {
#
#   echo "dm-env: Use Docker for Mac instead"
#   return 0
#
#   if [ -z "$1" ]; then
#     local machine=dev
#   else
#     local machine=$1
#   fi
#
#   # Check if a machine is already marked as active
#   if [[ "$DOCKER_MACHINE_NAME" == "$machine" ]]; then
#     return 0
#   fi
#
#   # Check if machine exists and is running
#   local machine_status=`docker-machine ls | grep ${machine} | awk '{print $4}'`
#   if [[ -z "$machine_status" ]]; then
#     # No machine found, create new machine
#     echo "*** Docker Machine \"${machine}\" does not exist, creating new machine..."
#     docker-machine create --driver virtualbox ${machine} \
#       || { echo "Failed to create new machine"; return 1; }
#   elif [[ "$machine_status" == "Running" ]]; then
#     # Machine running, activating it
#     echo "*** Docker Machine \"${machine}\" running, setting environment..."
#     eval $(docker-machine env ${machine})
#   else
#     # Starting existing machine
#     echo "*** Starting Docker Machine \"${machine}\"..."
#     docker-machine start ${machine} \
#       && eval $(docker-machine env ${machine})
#   fi
# }

# docker-ip() {
#   boot2docker ip 2> /dev/null
# }

# Initialise virtualenv with pyenv in autoenv
init-pyenv() {

  if [ -z "$1" ]; then
    local virtualenv=$(basename $(pwd))
  else
    local virtualenv=$1
  fi

  local python_version=${PYTHON_VERSION:=2.7.12}
  local pyenv_root=${PYENV_ROOT:=${HOME}/.pyenv}

  if [ -d "${pyenv_root}/versions/${virtualenv}" ]; then
    echo "*** Virtualenv $virtualenv found, activating..."
  else
    echo "*** Creating new virtualenv ${virtualenv}..."
    pyenv virtualenv ${python_version} ${virtualenv} \
      || { echo "Failed to create new virtualenv"; return 1; }
    echo "*** Virtualenv created, activating..."
    sleep 1
  fi

  pyenv activate ${virtualenv} \
    || { echo "Failed to activate virtualenv"; return 1; }

  echo "*** Updating .autoenv.zsh..."
  [ -e ".autoenv.zsh" ] \
    && gsed -i '/\(.*\) # Generated by init-pyenv/d' .autoenv.zsh
  echo "pyenv activate ${virtualenv} # Generated by init-pyenv" >> .autoenv.zsh

  echo "*** Updating .autoenv_leave.zsh..."
  [ -e ".autoenv_leave.zsh" ] \
    && gsed -i '/\(.*\) # Generated by init-pyenv/d' .autoenv_leave.zsh
  echo "pyenv deactivate # Generated by init-pyenv" >> .autoenv_leave.zsh

}

# Create Django secret
mk_dj_secret() {
  python -c "import random,string;print 'SECRET_KEY=\"%s\"'%''.join([random.SystemRandom().choice(\"{}{}{}\".format(string.ascii_letters, string.digits, string.punctuation)) for i in range(63)])" ;
}

# Create API key
mk_api_key() {
  local size=$1
  [ -z "$1" ] && size=16
  python -c "import random,string;print ''.join([random.SystemRandom().choice(\"{}{}{}\".format(string.ascii_letters, string.digits, string.punctuation)) for i in range(${size})]).encode('hex')" ;
}
